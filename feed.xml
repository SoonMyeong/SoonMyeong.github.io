<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://soonmyeong.github.io/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="https://soonmyeong.github.io/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2024-10-09T08:52:07+00:00</updated><id>https://soonmyeong.github.io/jekyll-theme-yat/feed.xml</id><title type="html">SoonWorld</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Soon</name></author><entry><title type="html">데이터중심 애플리케이션 설계 - 파티셔닝</title><link href="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/09/22/partitioning.html" rel="alternate" type="text/html" title="데이터중심 애플리케이션 설계 - 파티셔닝" /><published>2024-09-22T00:00:00+00:00</published><updated>2024-09-22T00:00:00+00:00</updated><id>https://soonmyeong.github.io/jekyll-theme-yat/book/2024/09/22/partitioning</id><content type="html" xml:base="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/09/22/partitioning.html"><![CDATA[<h1 id="목차">목차</h1>

<h2 id="1-파티셔닝">1. 파티셔닝</h2>
<ul>
  <li>이번장에서 다루는 파티셔닝은 대용량 데이터베이스를 의도적으로 작은단위로 쪼개는 방법인 샤딩을 뜻함.</li>
  <li>파티셔닝을 원하는 주된 이유는 ‘확장성’</li>
  <li>대용량 데이터셋을 파티셔닝 하는 몇가지 방법을 소개한다.</li>
  <li>파티셔닝의 리벨런싱(재균형화)에 대해서도 소개한다.</li>
  <li>데이터베이스가 어떻게 요청을 올바른 파티션에 전달하고 질의를 실행하는지 개략적으로 알아볼 예정</li>
</ul>

<h2 id="2-키-값-데이터-파티셔닝">2. 키-값 데이터 파티셔닝</h2>
<ul>
  <li>파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것임</li>
  <li>근데 파티셔닝이 고르게 이뤄지지 않으면?
    <ul>
      <li>다른 파티션보다 부하를 받는 파티션이 생기게 될텐데 이처럼 불균형하게 부하가 높은 파티션을 핫스팟 이라 부름</li>
    </ul>
  </li>
  <li>핫스팟을 회피하기 좋은 방법으로 키-값 데이터 모델(키 범위 기준, 키 해시값 기준)을 사용</li>
</ul>

<h3 id="2-1-키-범위-기준-파티셔닝">2-1. 키 범위 기준 파티셔닝</h3>
<ul>
  <li>종이 백과사전처럼 각 파티션에 연속된 범위의 키를 할당하는 것
    <ul>
      <li>각 범위들 사이의 경계를 알면 어떤 키가 어떤 파티션에 있는지 쉽게 찾을 수 있다.</li>
    </ul>
  </li>
  <li>키 범위의 크기가 반드시 동일할 필요는 없다.
    <ul>
      <li>why? 데이터가 고르게 분포하지 않을 수도 있기 때문
        <ul>
          <li>ex) 파티션은 12개, 키는 26개인 케이스에서 키의 범위를 2개씩만 동일하게 설정할 경우
    마지막 파티션에는 2개 이상의 키가 범위로 잡히게 된다.</li>
        </ul>
      </li>
      <li>데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.
        <ul>
          <li>이는 관리자가 수동으로 선택 or DB 가 자동으로 선택할 수 있다. (파티션 재균형화에서 계속)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다.</li>
</ul>

<h3 id="2-2-키-해시값-기준-파티셔닝">2-2. 키 해시값 기준 파티셔닝</h3>
<ul>
  <li>쏠림현상과 핫스팟 위험 때문에 많은 분산 데이터스토어에서는 해시함수를 사용한다.</li>
  <li>키에 적합한 해시함수를 구하고, 각 파티션에 키 범위 대신 해시값 범위를 할당하고 해시값이
파티션의 범위에 속하는 모든 키를 해당 파티션에 할당한다. (consistence hashing)</li>
  <li>대신 범위 질의를 효율적으로 실행할 수 없다. (키가 해시함수로 바뀌면서 모든 파티션에 흩어질거니까..)
    <h4 id="쏠린-작업부하와-핫스팟-완화">쏠린 작업부하와 핫스팟 완화</h4>
  </li>
  <li>해시값 기준으로 파티셔닝 시 핫스팟을 줄이는데 도움은 되지만 완벽히 제거할 순 없다.
    <ul>
      <li>항상 동일한 키를 읽고 쓰는 극단적 상황에서는… 모든 요청이 동일한 파티션으로 간다..</li>
      <li>이런 극단적 상황이 발생할 경우 애플리케이션에서 쏠림을 완화해야 한다.</li>
      <li>ex) 키의 시작이나 끝에 임의의 숫자를 붙인다. 등..
        <ul>
          <li>임의의 숫자를 붙임으로서 한 키에 대한 쓰기 작업이 다른 키로 균등하게 분산되고 다른파티션으로 분산될테니</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-보조색인-파티셔닝">3. 보조색인 파티셔닝</h2>
<ul>
  <li>위에서 설명한 키-값 데이터 모델은 레코드를 기본 키를 통해서만 접근한다.</li>
  <li>보조 색인이 있는 데이터베이스를 파티셔닝 하는데 쓰이는 방법에 대해 알아보자.</li>
</ul>

<h3 id="3-1-문서-기준-보조-색인-파티셔닝">3-1. 문서 기준 보조 색인 파티셔닝</h3>
<p>https://github.com/user-attachments/assets/5e6949ac-8ed0-4eba-a5e4-8f1798e4c254</p>
<ul>
  <li>예시로 알아보겠음</li>
  <li>예를 들어 중고차를 판매하는 웹사이트를 운영한다고 가정, 각 항목에는 문서ID 라 부르는 고유 ID 가 있고 데이터베이스를 문서ID 기준으로
파티셔닝 한다.</li>
  <li>사용자들이 차를 검색 시 색상과 제조사로 필터링하게 하려면 color 와 make 에 보조 색인을 만든다.
    <ul>
      <li>색인을 선언했다면 DB가 자동으로 색인 생성을 할 수 있다.</li>
    </ul>
  </li>
  <li>이럴 경우 각 파티션은 완전히 독립적으로 동작한다.</li>
  <li>각 파티션은 자신의 보조색인을 유지, 파티션에 속하는 문서만 담당
    <ul>
      <li>따라서 문서 파티셔닝 색인은 지역색인(local index) 이라고도 한다.</li>
    </ul>
  </li>
  <li>모든 파티션으로 질의를 보내 얻은 결과를 모두 모아야 되는 단점이 있다.
    <ul>
      <li>이 방법을 스캐터/개더 방식이라고도 한다.</li>
      <li>이래서 데이터베이스 벤더들은 대부분 보조 색인 질의가 단일 파티션에서만 실행되도록
  단파티셔닝 방식을 설계하기를 권장한다.</li>
    </ul>
  </li>
</ul>

<h3 id="3-2-용어-기준-보조-색인-파티셔닝">3-2. 용어 기준 보조 색인 파티셔닝</h3>
<p>https://github.com/user-attachments/assets/20947641-0f84-474e-b1f9-0552a91960c1</p>
<ul>
  <li>문서 기준 보조 색인처럼 지역색인하지말고 전역색인 하면 되지않을까?
    <ul>
      <li>그치만 한 노드에만 색인을 저장할 순 없다. 해당 노드에 병목되면?</li>
      <li>그래서 전역색인도 결국 파티셔닝을 해야하는데 기본키 색인과는 다른 식으로 할 수 있다.</li>
    </ul>
  </li>
  <li>그림을 보면 확인할 수 있는데 컬러 알파벳의 a~r 까지는 파티션0 에 색인, s~z 까지는 파티션1에 색인</li>
  <li>찾고자 하는 용어에 따라 색인의 파티션이 결정되므로 용어 기준으로 파티셔닝됐다고 한다.</li>
  <li>여기서 용어란 문서에 등장하는 모든 단어를 뜻한다.</li>
  <li>용어 자체로 파티셔닝 시 범위 스캔에 유용하며</li>
  <li>용어의 해시값으로 파티셔닝 시 부하가 더 고르게 분산된다.</li>
  <li>문서 파티셔닝 색인에 비해 읽기가 효율적인 장점이 있다.
    <ul>
      <li>모든 파티션에 스캐터/개더를 실행할 필요 없이 용어를 포함하는 파티션으로만 요청을 보내면 되니까</li>
    </ul>
  </li>
  <li>문서 파티셔닝 색인에 비해 쓰기가 느리다는 단점이 있다.
    <ul>
      <li>단일 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있기 때문</li>
    </ul>
  </li>
  <li>현실에서 전역 보조 색인은 대개 비동기로 갱신된다.
    <ul>
      <li>쓰기 실행 후 바로 조회 시 반영 안될 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="4-파티션-재균형화-리밸런싱">4. 파티션 재균형화 (리밸런싱)</h2>
<ul>
  <li>리벨런싱 : 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정</li>
  <li>리벨런싱 실행 시 만족 시킬 것으로 기대되는 최소 요구사항
    <ul>
      <li>리벨런싱 후 부하가 클러스터 내에 있는 노드들 사이 균등하게 분배</li>
      <li>리벨런싱 도중에도 데이터베이스 읽쓰기 요청 받아들여야 함</li>
      <li>노드들 사이 데이터가 필요 이상으로 옮겨지면 안됨 (속도 이슈)</li>
    </ul>
  </li>
</ul>

<h3 id="4-1-재균형화-전략">4-1. 재균형화 전략</h3>
<h3 id="4-2-파티션-개수-고정-파티셔닝">4-2. 파티션 개수 고정 파티셔닝</h3>
<ul>
  <li>파티션을 노드 대수 보다 많이 만들고 각 노드에 여러 파티션을 할당 하는 것</li>
  <li>클러스터에 노드 추가 시 새 노드는 파티션이 균일하게 분배될 때 까지 기존 노드에 있는 파티션 몇개를 뺏어온다.</li>
  <li>리밸런싱 중 들어오는 요청은 기존에 할당된 파티션을 사용</li>
  <li>장점 : 파티션을 통째로 이동, 그저 노드만 바뀔 뿐</li>
  <li>단점 : 파티션 수는 고정인데 전체 데이터셋 크기 변동이 심할경우 적절한 파티션 수 지정이 어렵다.
    <ul>
      <li>대부분 처음 설정된 파티션 수 = 사용 가능한 노드 대수의 최대치</li>
      <li>개별 파티션 크기는 클러스터 전체 데이터 크기에 비례한다.
        <ul>
          <li>파티션을 너무 크게 나누면 리밸런싱 작업이나 노드 장애 복구 시 비용이 많이든다. (크기가 크니까)</li>
          <li>파티션을 너무 작게 나누면 오버헤드가 너무 커진다. (리밸런싱 시 파티션 이동 작업 횟수 증가 등..)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>리악, 엘라스틱서치, 카우치베이스, 볼드모트 에서 사용됨</li>
</ul>

<h3 id="4-3-동적-파티셔닝">4-3. 동적 파티셔닝</h3>
<ul>
  <li>HBase 나 리싱크DB 는 파티션을 동적으로 만든다.</li>
  <li>파티션 개수가 전체 데이터 용량에 맞춰 조정된다는 이점이 있다.</li>
  <li>빈 데이터베이스의 경우 파티션 경계에 대한 사전 정보가 없으므로 시작 시 파티션이 하나라는 함정이 있음
    <ul>
      <li>이 문제를 완화하려고 초기 파티션 집합을 설정할 수 있게 함</li>
    </ul>
  </li>
</ul>

<h3 id="4-4-노드-비례-파티셔닝">4-4. 노드 비례 파티셔닝</h3>
<ul>
  <li>카산드라와 케타마 에서 사용하고 있으며 파티션 개수가 노드 대수에 비례하게 하는 것</li>
  <li>노드 당 파티션 개수를 고정 한다.</li>
  <li>일반적으로 데이터 용량이 증가할 수록 노드도 많이 필요하므로 이 방법을 쓰면 개별 파티션 크기도 상당히 안정적으로 유지 됨</li>
  <li>단점으로 신규 노드 추가로 파티션 분할 시 무작위로 분할되긴 하나 consistence hashing 기법을 사용하면 된다.</li>
</ul>

<h2 id="5-운영-시-리밸런싱-자동-or-수동">5. 운영 시 리밸런싱 (자동 or 수동)</h2>
<ul>
  <li>완전 자동 재균형화
    <ul>
      <li>유지보수에 손이 덜 가므로 편리할 수 있으나 예측이 어렵기도 하다.</li>
    </ul>
  </li>
  <li>리밸런싱 과정에서 사람이 개입하는게 좋을 수도 있다. (승인해주기)</li>
</ul>

<h2 id="6-요청-라우팅">6. 요청 라우팅</h2>
<p>https://github.com/user-attachments/assets/614d77a0-3a7d-45be-835d-d761ef748af0</p>
<ul>
  <li>서비스 디스커버리의 일종이다.</li>
  <li>많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 별도의 코디네이션 서비스를 사용함( ex. 주키퍼, k8s의 컨트롤플레인)</li>
</ul>

<h2 id="정리">정리</h2>
<ul>
  <li>주요 파티셔닝 기법
    <ul>
      <li>키범위 파티셔닝</li>
      <li>키 해시 파티셔닝</li>
    </ul>
  </li>
  <li>보조색인 파티셔닝 기법
    <ul>
      <li>문서 파티셔닝 색인</li>
      <li>용어 파티셔닝 색인</li>
    </ul>
  </li>
</ul>]]></content><author><name>Soon</name></author><category term="book" /><category term="partitioning" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">데이터중심 애플리케이션 설계 - 2장 데이터 모델과 질의 언어</title><link href="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/07/31/data-model-and-query.html" rel="alternate" type="text/html" title="데이터중심 애플리케이션 설계 - 2장 데이터 모델과 질의 언어" /><published>2024-07-31T00:00:00+00:00</published><updated>2024-07-31T00:00:00+00:00</updated><id>https://soonmyeong.github.io/jekyll-theme-yat/book/2024/07/31/data-model-and-query</id><content type="html" xml:base="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/07/31/data-model-and-query.html"><![CDATA[<h1 id="목차">목차</h1>

<h1 id="1-데이터-모델">1. 데이터 모델</h1>

<ul>
  <li>관계형 모델</li>
  <li>문서 모델</li>
  <li>그래프형 모델</li>
</ul>

<h1 id="2-데이터를-위한-질의-언어">2. 데이터를 위한 질의 언어</h1>

<ul>
  <li>선언형 질의</li>
  <li>맵리듀스 질의</li>
  <li>사이퍼 질의</li>
  <li>스파클 질의</li>
</ul>

<h1 id="내-언어의-한계는-내-세계의-한계를-의미한다"><em>“내 언어의 한계는 내 세계의 한계를 의미한다.”</em></h1>

<h2 id="루트비히-비트겐슈타인-논리-철학-논고1922">루트비히 비트겐슈타인, 논리-철학 논고(1922)</h2>

<h2 id="관계형-모델">관계형 모델</h2>

<ul>
  <li>오늘날 가장 잘 알려진 데이터 모델</li>
  <li>데이터는 (SQL 에서 테이블) 관계로 구성되고 각 관계는 순서 없는 튜플(SQL 에서 로우)의 모음</li>
  <li>이론적 제안으로부터 시작했으며 1980년대 중반 DBMS 와 SQL 은 정규화된 구조로 데이터 저장 및 질의할 필요가 있는 사람들 대부분이 선택하는 도구가 됨</li>
  <li>관계형 모델의 경쟁자들도 잠깐 등장했었지만.. 이내 사라져버렸음
    <ul>
      <li>객체 데이터베이스, XML 데이터베이스 등…</li>
    </ul>
  </li>
</ul>

<h3 id="nosql-의-탄생">NoSQL 의 탄생</h3>

<ul>
  <li>2010년대에 관계형 모델의 우위를 뒤집으려는 가장 최신 시도</li>
  <li>원래 NoSQL은 2009년에 오픈소스, 분산 환경, 비관계형 데이터베이스 밋업용 인기 트위터 해시태그였다.</li>
  <li>지금은 인기 있는 여러 데이터베이스 시스템과 #NoSQL 해시태그가 연관돼 있다.</li>
  <li>그래서 Not Only SQL 로 재해석됐다.
    <ul>
      <li>SQL만을 사용하지 않는 DBMS 를 지칭하는 단어 NoSQL,</li>
      <li>관계형 DB 뿐만 아니라 여려 유형의 데이터베이스도 사용한다
        <ul>
          <li>https://namu.wiki/w/NoSQL</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Why NoSQL ?
    <ul>
      <li>대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 DBMS 보다 쉽게 할 수 있는 확장성 만족</li>
      <li>상용 DB 제품 보다 무료 오픈소스 소프트웨어 선호도 확산</li>
      <li>DBMS 에서 지원하지 않는 특수 질의 동작</li>
      <li>DBMS 보다 더 동적이고 표현력이 풍부한 데이터 모델에 대한 바람..</li>
    </ul>
  </li>
  <li>가까운 미래에는 DBMS 와 비관계형 데이터스토어가 함께 사용될 것인데, 이러한 개념을 종종 “다중 저장소 지속성” 이라 한다.</li>
</ul>

<h2 id="관계형-모델의-단점은-무엇일까-문서-모델은-어떤가">관계형 모델의 단점은 무엇일까? 문서 모델은 어떤가?</h2>

<h3 id="객체와-관계형-간-불일치">객체와 관계형 간 불일치</h3>

<ul>
  <li>오늘날 대부분의 애플리케이션은 OOP 로 개발한다.</li>
  <li>이는 SQL 데이터 모델을 향한 공통된 비판을 불러온다!</li>
  <li>데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체(테이블,로우 컬럼) 사이에 거추장스러운 전환 계층이 필요하다..
    <ul>
      <li>“임피던스 불일치” 라고 부른다고 한다.</li>
    </ul>
  </li>
  <li>
    <p>액티브레코드(??) 나 하이버네이트 같은 객체 관계형 매핑 (ORM) 프레임워크는 전환 계층에 필요한 상용구 코드 (보일러플레이트 코드)의 양을 줄이지만 두 모델 간의 차이를 완벽히 숨기진 못한다.</p>
  </li>
  <li>예시) 관계형 스키마에서 이력서를 표현하는 방법</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/6ac1d5e8-2043-4bc9-a5d2-255914fbc27b" alt="image" /></p>

<ul>
  <li>예시) 위 예시를 문서모델인 JSON 으로 표현하는 방법</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
	<span class="dl">"</span><span class="s2">user_id</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">251</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">first_name</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Bill</span><span class="dl">"</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">last_name</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Gates</span><span class="dl">"</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">summary</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Co-chair of the Bill &amp; Melinda Gates ...</span><span class="dl">"</span><span class="p">,</span>
	<span class="o">**</span><span class="dl">"</span><span class="s2">region_id</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">us:91</span><span class="dl">"</span><span class="p">,</span>
	<span class="dl">"</span><span class="s2">industry_id</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">131</span><span class="p">,</span><span class="o">**</span>
	
	<span class="dl">"</span><span class="s2">positions</span><span class="dl">"</span> <span class="p">:</span> <span class="p">[</span>
		<span class="p">{</span><span class="dl">"</span><span class="s2">job_title</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Co-chair</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">organization</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Bill &amp; Melinda Gates Foundation</span><span class="dl">"</span><span class="p">},</span>
		<span class="p">{</span><span class="dl">"</span><span class="s2">job_title</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Co-founder, Chairman</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">organization</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Microsoft</span><span class="dl">"</span><span class="p">}</span>
	<span class="p">],</span>
	
	<span class="p">...</span>
	<span class="dl">"</span><span class="s2">contact_info</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span>
		<span class="dl">"</span><span class="s2">blog</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">http:// ...</span><span class="dl">"</span><span class="p">,</span>
		<span class="dl">"</span><span class="s2">twitter</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">http:// ...</span><span class="dl">"</span>
	<span class="p">}</span>
<span class="p">}</span>
	
</code></pre></div></div>

<ul>
  <li>“아 보기 좋다. JSON 모델 쓰면 임피던스 불일치를 줄일 수 있겠네”</li>
  <li>일부 개발자는 JSON 모델이 애플리케이션 코드와 저장 계층 간 임피던스 불일치를 줄인다고 생각한다.
    <ul>
      <li>4장에서 설명하지만 데이터 부호화 형식으로 JSON 이 가진 문제도 있음</li>
    </ul>
  </li>
  <li>JSON 표현은 다중 테이블 스키마보다 더 나은 <strong>“지역성”</strong>을 갖는다.
    <ul>
      <li>관계형 예제에서 프로필을 가져오려면 다중 질의 or 난잡한 다중 조인을 수행해야 함, but JSON 표현은 모든 관련 정보가 한 곳에 있어 질의 하나로 충분</li>
    </ul>
  </li>
  <li>일대다 관계는 의미상 <strong>데이터 트리구조와 같은데, JSON 표현에서 명시적으로 드러남.</strong></li>
</ul>

<p><img src="https://github.com/user-attachments/assets/114d900c-ce0d-4468-bae1-b99217c9a7a9" alt="image" /></p>

<h3 id="여기서-잠깐">여기서 잠깐..</h3>

<p>위 프로필 파일에서 왜 region_id 와 industry_id 는 문자로 표현하지 않았을까?</p>

<ul>
  <li>프로필 간 일관된 스타일과 철자</li>
  <li>모호함 회피 (같은 이름의 도시.. 가능성있음)</li>
  <li>갱신의 편의성</li>
  <li>현지화 지원</li>
  <li>더 나은 식별 ( ex. 지역목록에 시애틀이 워싱턴에 있다는 사실을 부호화)</li>
  <li>텍스트를 직접 저장 시 이를 사용하는 모든 레코드에서 정보를 중복으로 저장하게 된다.</li>
</ul>

<h3 id="그럼-id-쓰는-장점은">그럼 ID 쓰는 장점은..</h3>

<ul>
  <li>식별 정보를 변경해도 ID는 동일하게 유지할 수 있음
    <ul>
      <li>물론 ID가 의미를 가지는 경우 미래에 언젠가는 ID 를 변경해야 할 수도 있다.</li>
    </ul>
  </li>
  <li>만약 정보가 중복돼 있으면 모든 중복 항목을 변경 해야 한다.
    <ul>
      <li>이는 쓰기 오버헤드와 불일치 (일부 중복 항목이 갱신되지 않음) 위험이 있음.. 자세한건 3장</li>
    </ul>
  </li>
  <li>결국, 중복을 제거하는 일이 데이터베이스 정규화의 이면에 놓인 “핵심 개념” 이다.</li>
</ul>

<h3 id="중복된-데이터를-정규화-하려면">중복된 데이터를 정규화 하려면?</h3>

<ul>
  <li>다대일 관계가 필요함, 문서 모델에는 적합하지 않다.
    <ul>
      <li>RDB 는 조인이 쉽기 때문에 ID 로 다른 테이블의 로우를 참조하는 방식이 일반적임</li>
    </ul>
  </li>
  <li>문서 DB 는 일대다 트리 구조를 위해 조인이 필요하진 않다.(아까 예제) 그치만 조인에 대한 지원은 보통 약한 편임. ( ex. 몽고DB 의 조인 부재, 리싱크DB 는 조인을 지원하긴 함)
    <ul>
      <li>데이터베이스 자체가 조인을 지원 안하면?
        <ul>
          <li>다중 질의를 만들어 애플리케이션 코드에서 조인을 흉내내면 되긴함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>어쨋든 애플리케이션의 초기 버전이 조인 없는 문서 모델에 적합할지라도 기능이 추가되다 보면 결국 데이터는 상호 연결되는 경향이 있음.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/12f5e7f6-b303-4e47-8eb9-3daafcf019f3" alt="image" /></p>

<ul>
  <li>다대다 관계로 프로필이 확장 된 데이터 모델 형태
    <ul>
      <li>점선 내 데이터는 하나의 문서로 묶을 수 있으나 조직,학교, 기타 사용자는 참조로 표현해야 하고 질의할 때 조인이 필요함</li>
    </ul>
  </li>
  <li>document DB가 이렇게 허무하게 끝날 순 없다. 조금 더 살펴보자.</li>
</ul>

<h2 id="문서-데이터베이스의-역사">문서 데이터베이스의 역사</h2>

<ul>
  <li>이를 논하기 위해서는 가장 초기 전산화 데이터베이스 시스템으로 돌아간다…</li>
  <li>1970년대 비즈니스 데이터 처리를 위해 가장 많이 사용한 DB 는 IBM 의 IMS(정보 관리 시스템) 이였다.
    <ul>
      <li>계층 모델 이라 부르는 데이터 모델을 사용</li>
      <li>계층 모델은 JSON 모델과 비슷하다.</li>
      <li>역시나 IMS 도 일대다 관계에서는 잘 동작했다.. 문제는 다대다 관계 표현이였다..
        <ul>
          <li>오늘날 문서DB 를 사용해 작업 중인 개발자가 풀어야 할 문제와 매우 비슷하다.</li>
        </ul>
      </li>
      <li>계층 모델의 한계를 해결하기 위해 두드러지는 해결책은 2가지였다.
        <ul>
          <li>관계형 모델, 네트워크 모델</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="네트워크-모델에-대해">네트워크 모델에 대해</h3>

<ul>
  <li>코다실(CODASYL) 이라 불리는 위원회에서 표준화했으며 코다실 모델이라고도 부른다.</li>
  <li>코다실 모델은 <strong>계층 모델을 일반화</strong> 한다.
    <ul>
      <li>계층 모델의 트리 구조에서 모든 레코드는 정확히 하나의 부모가 있다.</li>
      <li>근데 네트워크 모델은 부모가 다중 부모….
        <ul>
          <li>ex. “그레이터 시애틀 구역” 지역을 위한 하나의 레코드는 이 지역에 사는 모든 사용자에 연결될 수 있다, 다대일과 다대다 관계를 모델링 할 수 있음.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>레코드 간 연결은 외래 키 보다 프로그래밍 언어의 포인터와 더 비슷함 (디스크에 저장은 됨)</li>
  <li>레코드에 접근하는 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법밖에 없다.
    <ul>
      <li>이를 “접근 경로” 라 한다.</li>
      <li>다대다 관계의 세계에서 다양한 다른 경로를 계속 추적해야 함..</li>
    </ul>
  </li>
  <li>그렇다면 레코드 질의는 ??
    <ul>
      <li>레코드 목록을 반환해 접근 경로를 따라 데이터베이스의 끝에서 끝까지 커서를 움직여 수행..</li>
      <li>레코드가 다중 부모면.. 다양한 관계를 모두 추적해야 한다.</li>
      <li>코다실 위원회도 이 방식이 n차원 데이터 공간을 항해하는것과 같다고 인정함</li>
    </ul>
  </li>
</ul>

<h3 id="관계형-데이터베이스와-문서-데이터베이스와의-비교">관계형 데이터베이스와 문서 데이터베이스와의 비교</h3>

<ul>
  <li>RDB 와 다르게 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드(일대다관계) 를 저장한다.</li>
  <li>다대일, 다대다 관계를 표현할 때 관계형 모델은 “외래키” 라는 식별자로 참조 하고 문서 모델에서는 “문서 참조” 라 부른다.</li>
</ul>

<h2 id="관계형-데이터베이스와-문서-데이터베이스">관계형 데이터베이스와 문서 데이터베이스</h2>

<ul>
  <li>두 DB 를 비교할 경우 내결함성, 동시성 처리 등 고려해야할 차이점이 있지만, 이번 장에서는 데이터 모델 차이점만 집중할 것임</li>
  <li>문서 데이터 모델을 선호하는 이유
    <ul>
      <li>스키마 유연성, 지역성에 기안한 더 나은 성능</li>
      <li>일부 애플리케이션의 경우 애플리케이션에서 쓰는 데이터 구조와 더 가까움</li>
    </ul>
  </li>
</ul>

<h3 id="어떤-데이터-모델이-애플리케이션-코드를-더-간단히-할까">어떤 데이터 모델이 애플리케이션 코드를 더 간단히 할까?</h3>

<ul>
  <li>애플리케이션에서 쓰는 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋음</li>
  <li>문서 모델에는 제한이 있음
    <ul>
      <li>문서 내 중첩 항목을 바로 참조할 수 없어서 (조인불가), 하지만 너무 깊게만 중첩되지 않으면 크게 문제가 되지 않음</li>
    </ul>
  </li>
  <li>애플리케이션에서 다대다 관계를 사용하면 문서 모델은 매력도 감소!</li>
</ul>

<h3 id="문서-모델의-스키마-유연성">문서 모델의 스키마 유연성</h3>

<ul>
  <li>문서 데이터베이스는 종종 스키마리스(schemaless)로 불리지만 이는 오해의 소지가 있다.
    <ul>
      <li>데이터를 읽는 코드는 보통 구조의 유형을 어느 정도 가정한다.</li>
      <li>즉, 암묵적 스키마는 있지만 데이터베이스가 강요하진 않음</li>
      <li>용어로 말하면 읽기스키마 라 할 수 있다.
        <ul>
          <li>데이터 구조는 암묵적이고 데이터를 읽을 때만 해석된다.</li>
        </ul>
      </li>
      <li>그럼 쓰기스키마는?
        <ul>
          <li>RDB 의 전통적 접근방식, 스키마는 명시적이고 DB 에 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>근데 이게 뭐?
    <ul>
      <li>스키마와 관련된 자세한 내용은 4장에서..</li>
    </ul>
  </li>
</ul>

<h3 id="문서-데이터베이스와-관계형-데이터베이스-통합">문서 데이터베이스와 관계형 데이터베이스 통합</h3>

<ul>
  <li>RDB 와 DocumentDB 는 시간이 지남에 따라 점점 더 비슷해지고 있다.</li>
</ul>

<h2 id="그래프형-데이터-모델">그래프형 데이터 모델</h2>

<ul>
  <li>앞에서 다대다 관계가 다양한 데이터 모델을 구별하는 중요한 기능임을 살펴봤다.</li>
  <li>다대다 관계가 매우 일반적인 경우라면?
    <ul>
      <li>관계형 모델은 단순한 다대다는 다룰 수 있으나 연결이 더 복잡해지면 그래프로 데이터를 모델링하기 시작하는 편이 더 자연스럽다.</li>
    </ul>
  </li>
  <li>그래프
    <ul>
      <li>정점(vertex, 노드나 엔티티) 간선 (edge, 관계나 호(arc))</li>
      <li>ex. 소셜 그래프 (정점 : 사람, 간선 : 사람 간 서로 알고 있음)</li>
      <li>ex. 웹 그래프 (정점 : 웹 페이지, 간선 : 다른 페이지에 대한 HTML 링크)</li>
      <li>ex. 도로나 철도 네트워크 (정점 : 교차로, 간선 : 교차로 간 도로나 철로 선)</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/user-attachments/assets/126bb8f1-efe8-46f5-b02e-4d7018110329" alt="image" /></p>

<ul>
  <li>이번 장에서는 속성 그래프모델과 트리플 저장소모델 에 대해 알아봄</li>
</ul>

<h3 id="속성-그래프">속성 그래프</h3>

<ul>
  <li>정점(vertex)
    <ul>
      <li>고유한 식별자</li>
      <li>유출(outgoing) 간선 집합</li>
      <li>유입(incoming) 간선 집합</li>
      <li>속성 컬렉션 (키-값 쌍)</li>
    </ul>
  </li>
  <li>간선(edge)
    <ul>
      <li>고유한 식별자</li>
      <li>간선이 시작하는 정점(꼬리 정점)</li>
      <li>간선이 끝나는 정점 (머리 정점)</li>
      <li>두 정점 간 관계 유형을 설명하는 레이블</li>
      <li>속성 컬렉션(키-값 쌍)</li>
    </ul>
  </li>
  <li>관계형 스키마를 사용해 속성 그래프 표현 하기</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">CREATE</span> <span class="nx">TABLE</span> <span class="nx">vertices</span> <span class="p">(</span>
	<span class="nx">vertex_id</span> <span class="nx">integer</span> <span class="nx">PRIMARY</span> <span class="nx">KEY</span><span class="p">,</span>
	<span class="nx">properties</span> <span class="nx">json</span>
<span class="p">);</span>

<span class="nx">CREATE</span> <span class="nx">TABLE</span> <span class="nx">edges</span> <span class="p">(</span>
	<span class="nx">edge_id</span> <span class="nx">integer</span> <span class="nx">PRIMARY</span> <span class="nx">KEY</span><span class="p">,</span>
	<span class="nx">tail_vertex</span> <span class="nx">integer</span> <span class="nx">REFERENCES</span> <span class="nx">vertices</span><span class="p">(</span><span class="nx">vertex_id</span><span class="p">),</span>
	<span class="nx">head_vertex</span> <span class="nx">integer</span> <span class="nx">ERFERENCES</span> <span class="nx">vertices</span><span class="p">(</span><span class="nx">vertex_id</span><span class="p">),</span>
	<span class="nx">label</span> <span class="nx">text</span><span class="p">,</span>
	<span class="nx">properties</span> <span class="nx">json</span>
<span class="p">);</span>

<span class="nx">CREATE</span> <span class="nx">INDEX</span> <span class="nx">egdes_tails</span> <span class="nx">ON</span> <span class="nx">edges</span> <span class="p">(</span><span class="nx">tail_vertex</span><span class="p">);</span>
<span class="nx">CREATE</span> <span class="nx">INDEX</span> <span class="nx">edges_heads</span> <span class="nx">ON</span> <span class="nx">edges</span> <span class="p">(</span><span class="nx">head_vertex</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>이 모델의 중요 포인트
    <ul>
      <li>정점은 다른 정점과 간선으로 연결됨. 특정 유형 제한하는 스키마 없음</li>
      <li>일련의 정점을 따라 앞뒤 방향으로 순회 (그래서 앞뒤로 인덱스 만듬)</li>
      <li>다른유형의 관계일 경우 다른 레이블을 사용하여 단일 그래프에 다른 유형의 정보를 저장할 수 있음</li>
    </ul>
  </li>
  <li>위 그림 2-5를 관계형 스키마로 표현했을 때 어려운 사례는?
    <ul>
      <li>국가마다 지역구조가 다름..</li>
    </ul>
  </li>
  <li>그래프는 발전성이 좋아 애플리케이션에 기능을 추가하는 경우 데이터 구조 변경을 수용하게끔 쉽게 확장할 수 있음
    <ul>
      <li>루시가 먹을 수 있는 안전한 음식이 무엇인가?</li>
    </ul>

    <p><img src="https://github.com/user-attachments/assets/3812f70a-84be-4403-b058-997eeb6a6b63" alt="image" /></p>
  </li>
</ul>

<h3 id="트리플-저장소">트리플 저장소</h3>

<ul>
  <li>트리플 저장소는 속성 그래프 모델과 거의 동등</li>
  <li>모든 정보를 주어(subject), 서술어 (predicate), 목적어 (object) 처럼 매우 간단한 세 부분 구문 형식으로 저장</li>
  <li>주어는 그래프의 정점(vertex)과 같음</li>
  <li>목적어,서술어
    <ul>
      <li>문자열이나 숫자 같은 원시 데이터타입값 일 경우
        <ul>
          <li>트리플의 서술어와 목적어는 주어 정점에서 속성의 키,값과 동등</li>
          <li>ex. (루시,나이,33) {”age” :33} 속성을 가진 정점 lucy</li>
        </ul>
      </li>
      <li>그래프의 다른 정점일 경우
        <ul>
          <li>서술어는 그래프의 간선, 주어는 꼬리 정점, 목적어는 머리 정점</li>
          <li>ex. (루시,결혼하다,알랭)  루시와 알랭은 정점, 서술어 결혼하다는 정점을 잇는 간선의 레이블</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>아…. 패스</li>
</ul>

<h3 id="그래프-데이터베이스와-네트워크-모델의-비교">그래프 데이터베이스와 네트워크 모델의 비교</h3>

<ul>
  <li>코다실 DB 에는 다른 레코드 타입과 중첩 가능한 레코드 타입을 지정하는 스키마가 있음.
    <ul>
      <li>근데 그래프 DB는 제한 없음. 모든 정점은 다른 정점으로 가는 간선을 가질 수 있음→ 그래프 DB 가 더 변화에 유연함</li>
    </ul>
  </li>
  <li>코다실 DB 에서 특정 레코드에 도달하는 유일한 방법은 레코드의 접근 경로 중 하나를 탐색 하는 방식임
    <ul>
      <li>그래프DB는 고유 ID를 가지고 임의 정점을 직접 참조하거나 색인을 사용해 특정 값을 가진 정점을 빠르게 찾을 수 있음</li>
    </ul>
  </li>
  <li>코다실에서 레코드의 하위 항목은 정렬된 집합이라 DB는 정렬을 유지해야하고 새로운 데이터 삽입 시 정렬된 집합에서 새로운 레코드 위치를 염두에 둬야 함
    <ul>
      <li>그래프DB는 정렬 안함, 질의를 만들 때만 결과 정렬할 수 있음</li>
    </ul>
  </li>
  <li>코다실은 모든 질의가 명령형이고 작성이 어렵고 스키마 변경 시 질의가 쉽게 손상 됨
    <ul>
      <li>그래프DB 는 사이퍼나 스파클 같은 고수준 선언형 질의 언어 제공</li>
    </ul>
  </li>
</ul>

<h2 id="데이터를-위한-질의-언어">데이터를 위한 질의 언어</h2>

<h3 id="선언형-질의-언어-sql">선언형 질의 언어 (SQL)</h3>

<ul>
  <li>목표를 달성하기 위한 방법이 아니라 알고자 하는 데이터의 패턴, 즉 결과가 충족해야 하는 조건과 데이터를 어떻게 변환할지를 지정하기만 하면 됨</li>
</ul>

<h3 id="맵리듀스-질의">맵리듀스 질의</h3>

<ul>
  <li>많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델, 구글에 의해 널리 알려짐</li>
  <li>일부 NoSQL 데이터 저장소는 제한된 형태의 맵리듀스를 지원
    <ul>
      <li>읽기 전용 질의를 수행할 때 사용</li>
      <li>맵리듀스는 10장에서 자세히 설명</li>
    </ul>
  </li>
  <li>지금은 몽고DB 모델 사용에 대해 알아봄</li>
  <li>ex. 지금부터 한 달에 얼마나 자주 상어를 발견하는지 질의하기</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">SELECT</span> 
	<span class="nx">date_trunc</span><span class="p">(</span><span class="dl">'</span><span class="s1">month</span><span class="dl">'</span><span class="p">,</span> <span class="nx">observation_timestamp</span><span class="p">)</span> <span class="nx">AS</span> <span class="nx">observation_month</span>
	<span class="p">,</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">num_animals</span><span class="p">)</span> <span class="nx">AS</span> <span class="nx">total_animals</span>
<span class="nx">FROM</span> <span class="nx">observations</span>
<span class="nx">WHERE</span> <span class="nx">family</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">sharks</span><span class="dl">'</span>
<span class="nx">GROUP</span> <span class="nx">BY</span> <span class="nx">observation_month</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>상어과에 속하는 종만 보이도록 관측치를 필터링 한 후 관측치가 발생한 달력의 월로 그룹화하고 마지막으로 해당 달의 모든 관측치에 보여진 동물 수를 합친다.</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">observations</span><span class="p">.</span><span class="nx">mapReduce</span><span class="p">(</span>
	<span class="kd">function</span> <span class="nx">map</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//2. js함수로 질의와 일치하는 모든 문서에 대해 한 번씩 호출</span>
		<span class="kd">var</span> <span class="nx">year</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">observationTimestamp</span><span class="p">.</span><span class="nx">getFullYear</span><span class="p">();</span>
		<span class="kd">var</span> <span class="nx">month</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">observationTimestamp</span><span class="p">.</span><span class="nx">getMonth</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="nx">emit</span><span class="p">(</span><span class="nx">year</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">-</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">month</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">numAnimals</span><span class="p">);</span>		
	<span class="p">},</span>
	
	<span class="kd">function</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">values</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 3. map 이 방출한 키-값 쌍은 키로 그룹화</span>
		<span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">sum</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span> <span class="c1">//4. reduce 함수는 특정 월의 모든 관측치에 동물 수를 합침</span>
	<span class="p">},</span>
	
	<span class="p">{</span>
		<span class="na">query</span> <span class="p">:</span> <span class="p">{</span><span class="na">fimaily</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Sharks</span><span class="dl">"</span><span class="p">},</span> <span class="c1">//1.필터를 선언, 맵리듀스를 위한 몽고DB에 특화된 확장 프로그램</span>
		<span class="na">out</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">monthlySharkReport</span><span class="dl">"</span><span class="c1">// 5. 최종 출력을 monthlySharkReport 컬렉션에 기록</span>
	<span class="p">}</span>

<span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>map 과 reduce 함수는 수행할 때 제약 사항이 있다.
    <ul>
      <li>pure(순수) 함수여야 한다.</li>
      <li>입력으로 전달된 데이터만 사용하고 추가적인 데이터베이스 질의를 수행할 수 없어야 하며, 사이드이펙트가 없어야 한다.
        <ul>
          <li>이 제약사항 때문에 DB가 임의 순서로 어디서나 이 함수를 실행할 수 있고 장애가 발생해도 함수를 재 실행할 수 있다.</li>
        </ul>
      </li>
      <li>문자열파싱 및 라이브러리 호출하고 계산 실행 등 작업에 이용할 수 있다.</li>
    </ul>
  </li>
  <li>몽고DB 에서 맵리듀스 사용성 문제는 연계된 JS 함수 두개(map, reduce) 를 신중하게 작성해야 한다는 점인데, 선언형 질의 언어는 옵티마이저가 질의 성능을 높일 수 있는 기회를 제공한다.
    <ul>
      <li>그래서 몽고 2.2 는 집계 파이프라인이라 부르는 선언형 질의 언어 지원을 추가함..</li>
    </ul>
  </li>
  <li>여기서 배울점은 NoSQL 시스템이 뜻하지 않게 SQL을 재발견하고 있다는 점임!</li>
</ul>

<h3 id="사이퍼-질의-언어">사이퍼 질의 언어</h3>

<ul>
  <li>속성 그래프를 위한 선언형 질의 언어
    <ul>
      <li>네오포제이 그래프 데이터베이스용으로 만들어짐</li>
    </ul>
  </li>
  <li>그림2-5의 왼쪽부분을 사이퍼 질의로 변경</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">CREATE</span>
	<span class="p">(</span><span class="nx">NAmerica</span><span class="p">:</span><span class="nx">Location</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">North America</span><span class="dl">'</span><span class="p">,</span> <span class="nx">type</span><span class="p">:</span><span class="dl">'</span><span class="s1">continent</span><span class="dl">'</span><span class="p">}),</span>
	<span class="p">(</span><span class="nx">USA</span><span class="p">:</span><span class="nx">Location</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">United States</span><span class="dl">'</span><span class="p">,</span> <span class="nx">type</span><span class="p">:</span><span class="dl">'</span><span class="s1">country</span><span class="dl">'</span><span class="p">}),</span>
	<span class="p">(</span><span class="nx">Idaho</span><span class="p">:</span><span class="nx">Location</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">Idaho</span><span class="dl">'</span><span class="p">,</span> <span class="nx">type</span><span class="p">:</span><span class="dl">'</span><span class="s1">state</span><span class="dl">'</span><span class="p">}),</span>
	<span class="p">(</span><span class="nx">Lucy</span><span class="p">:</span><span class="nx">Person</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">Lucy</span><span class="dl">'</span><span class="p">}),</span>
	
	<span class="p">(</span><span class="nx">Idaho</span><span class="p">)</span> <span class="o">-</span><span class="p">[:</span><span class="nx">WITHIN</span><span class="p">]</span><span class="o">-&gt;</span> <span class="p">(</span><span class="nx">USA</span><span class="p">)</span> <span class="p">[:</span><span class="nx">WITHIN</span><span class="p">]</span><span class="o">-&gt;</span> <span class="p">(</span><span class="nx">NAmerica</span><span class="p">),</span>
	<span class="p">(</span><span class="nx">Lucy</span><span class="p">)</span> <span class="o">-</span><span class="p">[:</span><span class="nx">BORN_IN</span><span class="p">]</span><span class="o">-&gt;</span> <span class="p">(</span><span class="nx">Idaho</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>하나더.. 미국에서 유럽으로 이민 온 모든사람들의 이름 찾기</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">MATCH</span>
	<span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="o">-</span><span class="p">[:</span><span class="nx">BORN_IN</span><span class="p">]</span><span class="o">-&gt;</span> <span class="p">()</span> <span class="o">-</span><span class="p">[:</span><span class="nx">WITHIN</span><span class="o">*</span><span class="mi">0</span><span class="p">..]</span><span class="o">-&gt;</span> <span class="p">(</span><span class="nx">us</span><span class="p">:</span><span class="nx">Location</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">United States</span><span class="dl">'</span><span class="p">}),</span>
	<span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="o">-</span><span class="p">[:</span><span class="nx">LIVES_IN</span><span class="p">]</span><span class="o">-&gt;</span> <span class="p">()</span> <span class="o">-</span><span class="p">[:</span><span class="nx">WITNIN</span><span class="o">*</span><span class="mi">0</span><span class="p">..]</span><span class="o">-&gt;</span> <span class="p">(</span><span class="nx">eu</span><span class="p">:</span><span class="nx">Location</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">Europe</span><span class="dl">'</span><span class="p">})</span>

<span class="nx">RETURN</span> <span class="nx">person</span><span class="p">.</span><span class="nx">name</span>

<span class="c1">//person 은 어떤 정점을 향하는 BORN_IN 유출 간선을 가짐.</span>
<span class="c1">//이 정점에서 name 속성이 'United States'인 Location 유형의 정점에 도달할 떄 까지</span>
<span class="c1">//WITHIN 유출 간선을 따라감</span>

<span class="c1">//같은 person 정점은 LIVES_IN 유출 간선을 가짐, 이 간선과 WITHIN 유출 간선을 따라가면</span>
<span class="c1">//결국 name 속성이 "Europe" 인 유형의 정점에 도달</span>
</code></pre></div></div>

<ul>
  <li>보통 선언형 질의 언어는 질의 작성 시 수행에 대해 자세히 지정할 필요가 없다.. (feat. 옵티마이저)</li>
</ul>

<h3 id="sql의-그래프-질의">SQL의 그래프 질의</h3>

<ul>
  <li>RDB 에서 그래프 데이터를 표현할 수 있나? 넵
    <ul>
      <li>그치만 약간 어렵다.</li>
    </ul>
  </li>
  <li>가변 순회 경로에 대한 질의 개념을 “재귀 공통 테이블 식” 을 사용해 표현할 수 있다.
    <ul>
      <li>postgreSQL, IBM DB2, Oracle, SQL 서버에서 지원</li>
    </ul>
  </li>
  <li>위에서 본 미국에서 유럽으로 이민 온 모든사람들의 이름찾기를 재귀 공통 테이블식 문법을 사용해 질의 해보기</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">WITH</span> <span class="nx">RECURSIVE</span>
	<span class="o">--</span> <span class="nx">in_usa</span> <span class="nx">는</span> <span class="nx">미국</span> <span class="nx">내</span> <span class="nx">모든</span> <span class="nx">지역의</span> <span class="nx">정점</span> <span class="nx">ID</span> <span class="nx">집합이다</span><span class="p">.</span>
	<span class="nx">in_usa</span><span class="p">(</span><span class="nx">vertex_id</span><span class="p">)</span> <span class="nx">AS</span> <span class="p">(</span>
		<span class="nx">SELECT</span> <span class="nx">vertex_id</span> <span class="nx">FROM</span> <span class="nx">vertices</span> <span class="nx">WHERE</span> <span class="nx">properties</span><span class="o">-&gt;&gt;</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">United States</span><span class="dl">'</span>
		<span class="err">#</span> <span class="mi">1</span><span class="p">.</span> <span class="nx">name이</span> <span class="nx">미국인</span> <span class="nx">정점을</span> <span class="nx">찾아</span> <span class="nx">in_use</span> <span class="nx">정점</span> <span class="nx">집합의</span> <span class="nx">첫</span> <span class="nx">element로</span> <span class="nx">만든다</span><span class="p">.</span>
	<span class="nx">UNION</span>
		<span class="nx">SELECT</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">tail_vertex</span> <span class="nx">FROM</span> <span class="nx">edges</span>
			<span class="err">#</span> <span class="mi">2</span><span class="p">.</span> <span class="nx">in_use</span> <span class="nx">집합의</span> <span class="nx">정점들은</span> <span class="nx">모둔</span> <span class="nx">within</span> <span class="nx">유입</span> <span class="nx">간선을</span> <span class="nx">따라가</span> <span class="nx">같은</span> <span class="nx">집합에</span> <span class="nx">추가한다</span><span class="p">.</span>
			<span class="err">#</span> <span class="nx">모든</span> <span class="nx">within</span> <span class="nx">간선을</span> <span class="nx">방문할</span> <span class="nx">때까지</span> <span class="nx">수행한다</span><span class="p">.</span>
			<span class="nx">JOIN</span> <span class="nx">in_usa</span> <span class="nx">ON</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">head_vertex</span> <span class="o">=</span> <span class="nx">in_usa</span><span class="p">.</span><span class="nx">vertex_id</span>
			<span class="nx">WHERE</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">within</span><span class="dl">'</span>
<span class="p">),</span>
<span class="o">--</span> <span class="nx">in_europe</span> <span class="nx">은</span> <span class="nx">유럽</span> <span class="nx">내</span> <span class="nx">모든</span> <span class="nx">지역의</span> <span class="nx">정점</span> <span class="nx">ID</span> <span class="nx">집합이다</span><span class="p">.</span>
	<span class="nx">in_europe</span><span class="p">(</span><span class="nx">vertex_id</span><span class="p">)</span> <span class="nx">AS</span> <span class="p">(</span>
		<span class="nx">SELECT</span> <span class="nx">vertex_id</span> <span class="nx">FROM</span> <span class="nx">vertices</span> <span class="nx">WHERE</span> <span class="nx">properties</span><span class="o">-&gt;&gt;</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Europe</span><span class="dl">'</span>
		<span class="err">#</span> <span class="mi">3</span><span class="p">.</span> <span class="nx">name</span> <span class="nx">이</span> <span class="nx">유럽인</span> <span class="nx">정점을</span> <span class="nx">찾아</span> <span class="mi">1</span><span class="nx">번과</span> <span class="nx">동일하게</span> <span class="nx">in_europe</span> <span class="nx">집합을</span> <span class="nx">만든다</span><span class="p">.</span>
	<span class="nx">UNION</span>
		<span class="nx">SELECT</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">tail_vertex</span> <span class="nx">FROM</span> <span class="nx">edges</span>
		<span class="nx">JOIN</span> <span class="nx">in_europe</span> <span class="nx">ON</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">head_vertex</span> <span class="o">=</span> <span class="nx">in_europe</span><span class="p">.</span><span class="nx">vertex_id</span>
		<span class="nx">WHERE</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">within</span><span class="dl">'</span>
	<span class="p">),</span>
<span class="o">--</span> <span class="nx">born_in_usa</span> <span class="nx">는</span> <span class="nx">미국에서</span> <span class="nx">태어난</span> <span class="nx">모든</span> <span class="nx">사람의</span> <span class="nx">정점</span> <span class="nx">ID</span> <span class="nx">집합이다</span><span class="p">.</span>
	<span class="nx">born_in_usa</span><span class="p">(</span><span class="nx">vertex_id</span><span class="p">)</span> <span class="nx">AS</span> <span class="p">(</span> 
		<span class="err">#</span> <span class="mi">4</span><span class="p">.</span> <span class="nx">미국에서</span> <span class="nx">태어난</span> <span class="nx">사람을</span> <span class="nx">찾기</span> <span class="nx">위해</span> <span class="nx">in_usa</span> <span class="nx">집합의</span> <span class="nx">각</span> <span class="nx">정점에</span> <span class="nx">대해</span> <span class="nx">born_in</span> <span class="nx">incoming</span> <span class="nx">간선을</span> <span class="nx">따라간다</span>
		<span class="nx">SELECT</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">tail_vertex</span> <span class="nx">FROM</span> <span class="nx">edges</span>
			<span class="nx">JOIN</span> <span class="nx">in_usa</span> <span class="nx">ON</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">head_vertex</span> <span class="o">=</span> <span class="nx">in_usa</span><span class="p">.</span><span class="nx">vertex_id</span>
			<span class="nx">WHERE</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">born_in</span><span class="dl">'</span>
	<span class="p">),</span>

	<span class="o">--</span> <span class="nx">lives_in_europe</span> <span class="nx">은</span> <span class="nx">유럽에서</span> <span class="nx">태어난</span> <span class="nx">모든</span> <span class="nx">사람의</span> <span class="nx">정점</span> <span class="nx">ID</span> <span class="nx">집합이다</span><span class="p">.</span>
	<span class="nx">lives_in_europe</span><span class="p">(</span><span class="nx">vertex_id</span><span class="p">)</span> <span class="nx">AS</span> <span class="p">(</span>
		<span class="err">#</span> <span class="mi">5</span><span class="p">.</span> <span class="nx">동일하게</span> <span class="nx">유럽에</span> <span class="nx">사는</span> <span class="nx">사람을</span> <span class="nx">찾기</span> <span class="nx">위해</span> <span class="nx">in_europe</span> <span class="nx">집합의</span> <span class="nx">각</span> <span class="nx">정점에서</span> <span class="nx">lives_in</span> <span class="nx">incoming</span> <span class="nx">간선을</span> <span class="nx">따라간다</span>
		<span class="nx">SELECT</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">tail_vertex</span> <span class="nx">FROM</span> <span class="nx">edges</span>
			<span class="nx">JOIN</span> <span class="nx">in_europe</span> <span class="nx">ON</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">head_vertex</span> <span class="o">=</span> <span class="nx">in_europe</span><span class="p">.</span><span class="nx">vertex_id</span>
			<span class="nx">WHERE</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">label</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">lives_in</span><span class="dl">'</span>
	<span class="p">)</span>

<span class="nx">SELECT</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">properties</span><span class="o">-&gt;&gt;</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span>
<span class="nx">FROM</span> <span class="nx">vertices</span>
<span class="o">--</span> <span class="nx">미국에서</span> <span class="nx">태어나</span> <span class="nx">유럽에서</span> <span class="nx">자란</span> <span class="nx">사람을</span> <span class="nx">찾아</span> <span class="nx">join</span> <span class="nx">한다</span><span class="p">.</span>
<span class="nx">JOIN</span> <span class="nx">born_in_usa</span> <span class="nx">ON</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">vertex_id</span> <span class="o">=</span> <span class="nx">born_in_usa</span><span class="p">.</span><span class="nx">vertex_id</span>
<span class="err">#</span> <span class="nx">마지막으로</span> <span class="nx">join을</span> <span class="nx">이용해</span> <span class="nx">미국에서</span> <span class="nx">태어난</span> <span class="nx">사람과</span> <span class="nx">유럽에서</span> <span class="nx">태어난</span> <span class="nx">사람의</span> <span class="nx">교집함을</span> <span class="nx">구한다</span><span class="p">.</span>
<span class="nx">JOIN</span> <span class="nx">lives_in_europe</span> <span class="nx">ON</span> <span class="nx">vertices</span><span class="p">.</span><span class="nx">vertex_id</span> <span class="o">=</span> <span class="nx">lives_in_europe</span><span class="p">.</span><span class="nx">vertex_id</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>가능은..하다..</li>
</ul>

<h3 id="스파클sparql-질의">스파클(SPARQL) 질의</h3>

<ul>
  <li>RDF 데이터 모델을 사용한 트리플 저장소 질의 언어</li>
  <li>RDF 데이터 모델
    <ul>
      <li>Resource Description Framework</li>
      <li>서로 다른 웹 사이트가 일관된 형식으로 데이터를 게시하기 위한 방법을 제안</li>
    </ul>
  </li>
  <li>미국에서 유럽으로 이민 온 모든사람들의 이름찾기</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">PREFIX</span> <span class="p">:</span> <span class="o">&lt;</span><span class="nx">urn</span><span class="p">:</span><span class="nx">example</span><span class="p">:</span><span class="o">&gt;</span>

<span class="nx">SELECT</span> <span class="p">?</span><span class="nx">personName</span> <span class="nx">WEHRE</span> <span class="p">{</span>
	<span class="p">?</span><span class="nx">person</span> <span class="p">:</span><span class="nx">name</span> <span class="p">?</span><span class="nx">personName</span><span class="p">,</span>
	<span class="p">?</span><span class="nx">person</span> <span class="p">:</span><span class="nx">bornIn</span> <span class="o">/</span> <span class="p">:</span><span class="nx">within</span><span class="o">*</span> <span class="sr">/ :name "United States" </span><span class="err">.
</span>	<span class="p">?</span><span class="nx">person</span> <span class="p">:</span><span class="nx">liveIn</span> <span class="o">/</span> <span class="p">:</span><span class="nx">within</span><span class="o">*</span> <span class="sr">/ :name "Europe" </span><span class="err">.
</span><span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>구조는 사이퍼형태와 유사하다.
    <ul>
      <li>아래 두 표현식은 동등하다.
        <ul>
          <li>(person) -[:BORN_IN]-&gt; () -[:WITHIN*0..]-&gt; (location)  # 사이퍼</li>
          <li>?person :bornIn / :within* ?location #스파클</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="초석-데이터로그">초석: 데이터로그</h3>

<ul>
  <li>스파클이나 사이퍼보다 훨씬 오래된 언어 (1980년대 학계에서 광범위하게 연구됨)</li>
  <li>데이토믹을 질의 언어로 사용</li>
  <li>캐스캘로그는 데이터로그의 구현체로 하둡의 대용량 데이터셋 질의를 위한 용도</li>
</ul>]]></content><author><name>Soon</name></author><category term="book" /><category term="datamodel" /><category term="sql" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">대규모시스템설계기초- 9장 웹크롤러 설계</title><link href="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/06/18/web-crawler.html" rel="alternate" type="text/html" title="대규모시스템설계기초- 9장 웹크롤러 설계" /><published>2024-06-18T00:00:00+00:00</published><updated>2024-06-18T00:00:00+00:00</updated><id>https://soonmyeong.github.io/jekyll-theme-yat/book/2024/06/18/web-crawler</id><content type="html" xml:base="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/06/18/web-crawler.html"><![CDATA[<h1 id="웹-크롤러의-목적">웹 크롤러의 목적</h1>

<ul>
  <li>웹에 새로 올라오거나 갱신된 콘텐츠를 찾아 내는 것</li>
</ul>

<h2 id="크롤러의-종류">크롤러의 종류</h2>

<ul>
  <li>검색 엔진 인덱싱
    <ul>
      <li>가장 보편적인 용례</li>
      <li>ex) 구글 검색 엔진이 사용하는 웹 크롤러 = 구글봇</li>
    </ul>
  </li>
  <li>웹 아카이빙
    <ul>
      <li>나중에 사용할 목적으로 장기보관을 위해 웹에서 정보를 모으는 절차</li>
    </ul>
  </li>
  <li>웹 마이닝
    <ul>
      <li>인터넷에서 유용한 지식을 도출해 낼 수 있는 것</li>
      <li>ex) 주주총회 자료나 연차 보고서 같은걸 다운 받아 기업의 핵심 사업방향 캐치</li>
    </ul>
  </li>
  <li>웹 모니터링
    <ul>
      <li>인터넷에서 저작권이나 상표권이 침해되는 사례 모니터링</li>
    </ul>
  </li>
</ul>

<h1 id="1단계-문제-이해-및-설계-범위-확정">1단계. 문제 이해 및 설계 범위 확정</h1>

<p>웹 크롤러의  기본 알고리즘</p>

<ol>
  <li>URL 집합이 입력으로 주어지면, 해당 URL 들이 가리키는 모든 웹페이지 다운로드</li>
  <li>다운받은 웹페이지에서 URL들을 추출</li>
  <li>추출된 URL 들을 다운로드할 URL 목록에 추가하고 위 과정을 처음부터 반복</li>
</ol>

<p>이번에 설계할 크롤러는 검색 엔진 인덱싱에 쓰일 크롤러</p>

<h3 id="좋은-웹-크롤러가-만족시켜야-할-속성">좋은 웹 크롤러가 만족시켜야 할 속성</h3>

<ul>
  <li>규모 확장성
    <ul>
      <li>웹은 거대하기 때문에 병행성을 활용 시 보다 효과적</li>
    </ul>
  </li>
  <li>안정성
    <ul>
      <li>비정상적 입력이나 환경에 잘 대응해야 함</li>
    </ul>
  </li>
  <li>예절
    <ul>
      <li>짧은 시간에 너무 많은 요청은… X</li>
    </ul>
  </li>
  <li>확장성
    <ul>
      <li>새로운 형태의 콘텐츠를 지원하기 쉬워야 한다</li>
    </ul>
  </li>
</ul>

<h1 id="2단계-개략적-설계안-제시-및-동의-구하기">2단계. 개략적 설계안 제시 및 동의 구하기</h1>

<p><img src="https://github.com/SoonMyeong/SoonMyeong.github.io/assets/31875043/00eaab6e-15a5-4832-a335-55d16da4b707" alt="1" /></p>

<p>그림1. 설계안</p>

<ul>
  <li>이 구조는 http://infolab.stanford.edu/~olston/publications/crawling_survey.pdf 를 참고함</li>
</ul>

<h3 id="시작-url-집합">시작 URL 집합</h3>

<ul>
  <li>웹 크롤러가 크롤링을 시작하는 출발점</li>
  <li>전체 웹을 크롤링 할 경우 일반적으로 전체 URL 공간을 작은 부분집합으로 나누는 전략을 쓴다.</li>
</ul>

<h3 id="미수집-url-저장소">미수집 URL 저장소</h3>

<ul>
  <li>다운로드할 URL을 저장 관리하는 큐라고 생각하면 됨</li>
</ul>

<h3 id="도메인-이름-변환기">도메인 이름 변환기</h3>

<ul>
  <li>URL 을 IP 주소로 변환하는 절차</li>
</ul>

<h3 id="콘텐츠-파서">콘텐츠 파서</h3>

<ul>
  <li>웹페이지 다운 후 파싱과 검증 절차를 담당
    <ul>
      <li>이상한 웹 페이지를 걸러내기 위해</li>
    </ul>
  </li>
</ul>

<h3 id="중복-컨텐츠">중복 컨텐츠?</h3>

<ul>
  <li>웹 페이지의 해시 값을 비교 해 중복을 줄여 데이터 처리 소요 시간을 줄이는 목적</li>
</ul>

<h3 id="컨텐츠-처장소">컨텐츠 처장소</h3>

<ul>
  <li>HTML 문서 저장소</li>
  <li>인기 있는 컨텐츠는 메모리에 두어 접근 지연시간을 줄일 것</li>
</ul>

<h3 id="url-추출기">URL 추출기</h3>

<ul>
  <li>HTML 페이지 파싱 하여 링크 골라내는 역할</li>
  <li>상대 경로는 전부 절대경로로 변환</li>
</ul>

<h3 id="url-필터">URL 필터</h3>

<ul>
  <li>크롤링 대상에서 배제하는 역할</li>
</ul>

<h3 id="이미-방문한-url">이미 방문한 URL?</h3>

<ul>
  <li>이미 방문한적 있는 URL 인지 체크하는 역할</li>
  <li>블룸필터나 해시테이블이 널리 쓰임</li>
</ul>

<h3 id="url-저장소">URL 저장소</h3>

<ul>
  <li>이미 방문한 URL을 보관하는 저장소</li>
</ul>

<h2 id="웹-크롤러-작업-흐름">웹 크롤러 작업 흐름</h2>

<p><img src="https://github.com/SoonMyeong/SoonMyeong.github.io/assets/31875043/3d6eb3b1-f156-4089-8de1-5e808771c879" alt="3" /></p>

<p>6.저장소에 없는 컨텐츠면 저장소에 저장한 뒤 URL 추출기로 전달 <br />
7.추출기에서 링크를 골라냄<br />
11.저장소에 없는 URL은 URL 저장소에 저장할 뿐만아니라 미수집 URL 저장소에도 전달한다.</p>
<ul>
  <li>해당 URL 은 추출만 했고 컨텐츠를 안뽑아먹었으니까</li>
</ul>

<h1 id="3단계-상세-설계">3단계. 상세 설계</h1>

<h3 id="dfs-vs-bfs">DFS vs BFS</h3>

<ul>
  <li>DFS 로 구성 시 깊이가 어느정도 깊게 가게될지 가늠하기 어려움</li>
  <li>그래서 보통 BFS 를 사용함</li>
  <li>보통 큐의 한쪽에는 탐색할 URL을 집어넣고, 다른 한쪽은 꺼내기만 하는데..
    <ul>
      <li>한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다.</li>
      <li>병렬로 처리 시 예의 없는 크롤러로 간주된다.</li>
    </ul>
  </li>
  <li>표준 BFS 알고리즘은 URL 간 우선순위를 두지 않음.
    <ul>
      <li>페이지 순위, 트래픽양, 업데이트 빈도 등 여러 가지 척도에 비춰 처리 우선순위를 구별하는 것이 온당하다.</li>
    </ul>
  </li>
</ul>

<h3 id="미수집-url-저장소-1">미수집 URL 저장소</h3>

<ul>
  <li>미수집 URL 저장소로 위 문제를 쉽게 해결 할 수 있다.
    <ul>
      <li>URL 사이의 우선순위와 신선도를 구별하는 크롤러를 구현할 수 있어서</li>
    </ul>
  </li>
  <li>예의
    <ul>
      <li>예의바른 크롤러로 만드는 데 있어 지켜야 할 한가지 원칙
        <ul>
          <li>동일 웹 사이트에 대해 한 번에 한 페이지만 요청한다.</li>
          <li>같은 웹 사이트의 페이지를 다운받는 태스크는 시간차를 두고 실행할 것</li>
          <li>위 요구사항을 만족하려면 웹사이트의 호스트명과 작업스레드 사이의 관계를 유지 하면 됨
            <ul>
              <li>다운로드 스레드는 별도 큐를 가지고 있어 해당 큐에서 꺼낸 URL 만 다운로드 한다.</li>
            </ul>
          </li>
        </ul>

        <p><img src="https://github.com/SoonMyeong/SoonMyeong.github.io/assets/31875043/f46b639e-c37e-422e-b9b0-4225bfc73f7b" alt="4" /></p>
      </li>
      <li>큐 라우터 : 같은 호스트에 속한 URL은 언제나 같은 큐 (b1, b2…) 로 가도록 보장</li>
      <li>매핑 테이블 : 호스트 이름과 큐 사이의 관계 매핑</li>
      <li>큐 : 같은 호스트에 속한 URL 은 언제나 같은 큐에 보관 됨</li>
      <li>큐 선택기 : 큐 선택기는 큐를 순회하며 큐에서 URL 을 꺼내 지정된 스레드에 전달</li>
      <li>작업스레드
        <ul>
          <li>전달된 URL 을 다운로드하는 작업 수행</li>
          <li>전달된 URL 은 순차 처리 &amp; 일정 지연시간 둘 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>우선순위
    <ul>
      <li>
        <p>페이지랭크, 트래픽양, 갱신 빈도 등 다양한 척도를 사용할 수 있음</p>

        <p><img src="https://github.com/SoonMyeong/SoonMyeong.github.io/assets/31875043/667ab323-53a2-4471-9e08-3a85b1bbc764" alt="5" /></p>

        <ul>
          <li>큐 선택기 : 우선순위가 높을수록 큐에서 더 자주 꺼내도록 프로그램되어 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>예절과 우선순위를 합친 모습</li>
</ul>

<p><img src="https://github.com/SoonMyeong/SoonMyeong.github.io/assets/31875043/b67070be-58e4-4636-b377-d0a192162a16" alt="6" /></p>

<ul>
  <li>신선도
    <ul>
      <li>최신데이터를 유지하기 위해 이미 다운로드한 페이지라해도 주기적으로 재수집할 필요가 있음</li>
      <li>우선순위를 활용해 중요한 페이지 위주로 좀 더 재수집</li>
    </ul>
  </li>
</ul>

<h3 id="html-다운로더">HTML 다운로더</h3>

<ul>
  <li>로봇 제외 프로토콜 (Robot Exclusion Protocol)</li>
  <li>Robots.txt
    <ul>
      <li>웹사이트가 크롤러와 소통하는 표준방법</li>
      <li>Robots.txt 파일을 중복 다운로드 하는 것을 피하기 위해 이 파일은 주기적으로 다시 받아 캐시에 보관</li>
    </ul>
  </li>
  <li>성능 최적화
    <ul>
      <li>분산 크롤링: 크롤링 작업을 여러 서버에 분산</li>
      <li>도메인 이름 변환 결과 캐시
        <ul>
          <li>DNS 요청을 보내고 결과 받는 작업의 동기적 특성 때문에 이를 캐시하여 성능 올리기
            <ul>
              <li>주기적으로 도메인이름과 IP 관계 크론 잡 등을 돌려 갱신 설정</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>지역성
        <ul>
          <li>서버 지역별로 분산</li>
        </ul>
      </li>
      <li>짧은 타임아웃</li>
    </ul>
  </li>
  <li>안정성
    <ul>
      <li>안정 해시</li>
      <li>크롤링 상태 및 수집 데이터 저장</li>
      <li>예외처리</li>
      <li>데이터 검증</li>
    </ul>
  </li>
  <li>
    <p>확장성</p>

    <p><img src="https://github.com/SoonMyeong/SoonMyeong.github.io/assets/31875043/ed8af051-7a13-4c67-88a1-2ccf9f5de15b" alt="7" /></p>

    <h3 id="문제-있는-컨텐츠-감지-및-회피">문제 있는 컨텐츠 감지 및 회피</h3>

    <ul>
      <li>중복 컨텐츠 : 웹 컨텐츠의 30% 가량은 중복이다. 해시나 체크섬 사용 하여 중복 탐지</li>
      <li>거미 덫
        <ul>
          <li>만능 해결책 따윈 없음.</li>
          <li>사람이 수작업으로 덫을 확인하고 찾아낸 후 덫이 있는 사이트는 크롤러 탐색 대상에서 제외하거나 URL 필터 목록에 걸어두기</li>
        </ul>
      </li>
      <li>데이터 노이즈
        <ul>
          <li>쓸모없는건 제외</li>
        </ul>
      </li>
    </ul>

    <p>그림출처</p>
    <ul>
      <li><a href="https://velog.io/@kyy00n/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88-9%EC%9E%A5.-%EC%9B%B9-%ED%81%AC%EB%A1%A4%EB%9F%AC-%EC%84%A4%EA%B3%84">https://velog.io/@kyy00n/대규모-시스템-설계-기초-9장.-웹-크롤러-설계</a></li>
      <li>https://jonghoonpark.com/2023/06/22/web-crawler</li>
    </ul>
  </li>
</ul>]]></content><author><name>Soon</name></author><category term="book" /><category term="crawler" /><category term="web" /><summary type="html"><![CDATA[웹 크롤러의 목적]]></summary></entry><entry><title type="html">대규모시스템설계기초- 5장 안정 해시 설계</title><link href="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/05/18/consistent-hash.html" rel="alternate" type="text/html" title="대규모시스템설계기초- 5장 안정 해시 설계" /><published>2024-05-18T00:00:00+00:00</published><updated>2024-05-18T00:00:00+00:00</updated><id>https://soonmyeong.github.io/jekyll-theme-yat/book/2024/05/18/consistent-hash</id><content type="html" xml:base="https://soonmyeong.github.io/jekyll-theme-yat/book/2024/05/18/consistent-hash.html"><![CDATA[<p>대부분의 그림 출처 : <a href="https://donghyeon.dev/%EC%9D%B8%ED%94%84%EB%9D%BC/2022/03/20/%EC%95%88%EC%A0%95-%ED%95%B4%EC%8B%9C-%EC%84%A4%EA%B3%84/">https://donghyeon.dev/인프라/2022/03/20/안정-해시-설계/</a></p>

<h3 id="들어가면서-">들어가면서 …</h3>

<p>수평적 규모 확장성을 달성하기 위해 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요하다.</p>

<ul>
  <li>안정 해시는 이 목표를 달성하기 위해 보편적으로 사용하는 기술이다.</li>
</ul>

<h3 id="해시-키-재배치rehash-문제-안정해시가-나오게-된-배경">해시 키 재배치(rehash) 문제 (안정해시가 나오게 된 배경)</h3>

<p>N개의 서버를 균등하게 나누는 보편적 방법은 아래 해시 함수를 사용하는 것이다.</p>

<ul>
  <li>serverIndex = hash(key) % N (N : 서버 개수) - 모듈러 연산</li>
</ul>

<h3 id="모듈러-연산-예제">모듈러 연산 예제</h3>

<p>서버가 4대 인 경우</p>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/2ada9666-991b-4347-98b0-e5e1c3bdf4a3" alt="image" /></p>

<ul>
  <li>대략적인 해시와 모듈러연산 결과 표</li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/02477f78-e561-4093-afa8-203126299c5c" alt="image" /></p>

<ul>
  <li>서버 <strong>풀의 크기가 고정</strong>되어 있을 때 &amp; <strong>데이터 분포가 균등</strong>할 때는 잘 동작한다.</li>
  <li><strong>서버가 추가되거나 기존 서버가 삭제 되면 문제가 생긴다.</strong></li>
</ul>

<h3 id="위-예제에서-1번-서버가-장애를-일으켜-동작을-중단했을-경우">위 예제에서 1번 서버가 장애를 일으켜 동작을 중단했을 경우</h3>

<ul>
  <li>해시 값은 변하지 않지만 모듈러 연산을 적용하여 계산된 <strong>서버 인덱스 값은 달라지게 됨</strong>
    <ul>
      <li>serverIndex = hash(key) % N (N : 서버 개수) 해당 계산 식에서 N 값이 바뀌었기 때문</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/7fb360fd-3522-465b-9acd-d30ee32e98be" alt="image" /></p>

<ul>
  <li>서버 개수의 변화로 모듈러연산 결과가 이전과 완전 다르게 바뀌었다.</li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/8d080f8d-b9bd-41c8-9a8f-8fa054fd0f65" alt="image" /></p>

<ul>
  <li>결과로 대부분의 키가 재분배 되었다.</li>
  <li><strong>안정해시는 이 문제를 효과적으로 해결하기 위한 기술이다.</strong></li>
</ul>

<h2 id="안정해시">안정해시</h2>

<ul>
  <li>해시테이블 크기가 조정될 때 평균적으로 오직 k/n 개의 키만 재배치하는 해시 기술
    <ul>
      <li>k: 키의 개수, n : 슬롯 개수</li>
    </ul>
  </li>
</ul>

<h3 id="해시-공간과-해시-링">해시 공간과 해시 링</h3>

<ul>
  <li>해시 공간
    <ul>
      <li>해시 함수 f는 SHA(Secure Hash Algorithm)-1을 사용한다고 가정.
        <ul>
          <li>근데 SHA-1 은 해시충돌이 발견되어 현재 지원은 중단된 상태
            <ul>
              <li>https://cpuu.postype.com/post/580053</li>
            </ul>
          </li>
          <li>아마 보통은 SHA-2 를 쓸 것임
            <ul>
              <li>우리가 흔히 알고있는 SHA-256, SHA-512, SHA-224, SHA-384 를 통칭 하여 SHA-2 라고 부른다고 함</li>
              <li>2015년에 나온 SHA-3 도 있음..</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>SHA-1의 해시 공간 범위는 2^160 -1 까지라 알려져 있다는데 모듈러 연산결과는 x0(0) ~ xn(2^160 -1) 의 값을 갖게 될 것이다. 이걸 해시 공간이라 부른다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/f288371e-b2e1-4f7a-ad2e-36df98be5e62" alt="image" /></p>

<ul>
  <li>해시 링
    <ul>
      <li>이러한 해시 공간의 양쪽을 구부려 접은걸 해시 링 이라고 한다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/beb57cd8-f453-4c59-9b11-30d3b8ab425a" alt="image" /></p>

<h3 id="해시-서버--해시-키">해시 서버 &amp; 해시 키</h3>

<ul>
  <li>균등분포 해시함수를 사용하여 서버 IP 나 이름 같은걸 해시 링에 배치한 결과</li>
  <li>모듈러 연산을 사용하지 않음</li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/a58d28eb-7876-4afd-97a6-b68a2fa8a062" alt="image" /></p>

<h3 id="서버-조회-시">서버 조회 시</h3>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/a7ebead9-4808-467a-bb7f-baee4d311505" alt="image" /></p>

<ul>
  <li>key는 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버에 저장 된다.</li>
</ul>

<h3 id="서버-추가-시">서버 추가 시</h3>

<ul>
  <li>서버 추가 시 키 가운데 일부만 재배치하면 된다.</li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/ddab5c80-1608-4876-833d-05fab8814206" alt="image" /></p>

<h3 id="서버-제거-시">서버 제거 시</h3>

<ul>
  <li>key 1만 재배치 되었다.</li>
</ul>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/330144ab-d7b3-4319-bd72-7ba1f3e9617e" alt="image" /></p>

<h2 id="위-구현법의-2가지-문제">위 구현법의 2가지 문제</h2>

<ul>
  <li>파티션의 크기를 균등하게 유지하는 게 불 가능하다.(위 예제 처럼)
    <ul>
      <li>여기서 말하는 파티션 : 인접한 서버 사이의 해시 공간</li>
    </ul>
  </li>
  <li>키의 균등 분포를 달성하기가 어렵다.</li>
</ul>

<h2 id="가상-노드">가상 노드</h2>

<ul>
  <li>위 문제를 해결하기 위해 제안된 기법</li>
  <li>하나의 서버는 링 위에 여러개의 가상 노드를 가질 수 있다.</li>
</ul>

<h3 id="예제">예제</h3>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/4e3ff0b1-7b8a-4a06-9003-e109379137b0" alt="image" /></p>

<ul>
  <li>서버0과 서버1은 각각 3개의 가상노드를 가지고 있다.</li>
  <li>따라서 각 서버는 여러개의 파티션을 관리해야 한다.
    <ul>
      <li>서버0 : 서버0_0, 서버0_1, 서버0_2 파티션 관리</li>
      <li>서버1: 서버1_0, 서버1_1, 서버1_2 파티션 관리</li>
    </ul>
  </li>
</ul>

<h3 id="위-예제에서-키가-들어오게-되면-어떻게-배치되는지">위 예제에서 키가 들어오게 되면 어떻게 배치되는지</h3>

<p><img src="https://github.com/SoonMyeong/programmers/assets/31875043/08749210-9646-4d98-9d18-a305356c6ce6" alt="image" /></p>

<ul>
  <li>기존 해시링에서 키를 저장하는 방법과 동일하게 key를 기준으로 시계방향으로 돌면서 가장 먼저 만나는 가상노드가 나타내는 서버에 저장되게 된다.</li>
  <li>
    <p>key0 는 최초로 만나게되는 서버는 가상노드 서버1_1이고, 결국 key0 은 서버 1에 저장된다.</p>
  </li>
  <li>가상노드의 개수를 늘리면 키의 분포는 점점 더 균등해진다. (표준편차가 작아져서)</li>
  <li>대신 그만큼 가상노드를 저장할 공간이 더 필요하게 된다.
    <ul>
      <li>타협적 결정이 필요함</li>
      <li>한마디로 <strong>시스템 요구사항에 맞게 적절히 조정해야 함</strong> (알잘딱깔센, 제일 어려운 말)</li>
    </ul>
  </li>
</ul>

<h2 id="마치며">마치며</h2>

<ul>
  <li>안정 해시의 장점
    <ul>
      <li>서버 추가 or 삭제 시 재배치 되는 키의 수가 최소화 된다.</li>
      <li>데이터가 보다 균등하게 분포되어 수평적 규모 확장성을 달성하기 쉽다.
        <ul>
          <li>핫스팟 키 문제를 줄인다. 특정 샤드에 대한 접근이 지나치게 빈번해지는 문제가 생길 가능성을 줄인다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="실제-안정-해시를-쓰는-예">실제 안정 해시를 쓰는 예</h3>

<ul>
  <li>
    <p><a href="https://dl.acm.org/doi/10.1145/1294261.1294281">아마존 다이나모 DB 파티셔닝 관련 컴포넌트</a> <br />
  <img src="https://github.com/SoonMyeong/programmers/assets/31875043/734db5a3-1780-434d-9b2f-dde50c39b990" alt="image" /></p>
  </li>
  <li><a href="https://www.cs.cornell.edu/Projects/ladis2009/papers/lakshman-ladis2009.pdf">아파치 카산드라 클러스터에서의 데이터 파티셔닝</a>
    <ul>
      <li>5.1 파티셔닝 부분</li>
      <li>The basic consistent hashing algorithm presents some challenges.
  First, the random position assignment of each node on the
  ring leads to non-uniform data and load distribution. Second, the basic algorithm is oblivious to the heterogeneity in the performance of nodes
        <ul>
          <li>문서 내용을 보면 책에서 말한 설명을 그대로 하고 있음</li>
        </ul>
      </li>
      <li>One is for nodes to get assigned to multiple positions in the circle (like in Dynamo), and the second is to analyze load information on the ring and have lightly loaded nodes move on the ring to alleviate heavily loaded nodes as described in [17]. Cassandra opts for the latter as it makes the design and implementation very tractable and helps to make very deterministic choices about load balancing
        <ul>
          <li>얘네는 노드가 다이나모DB 처럼 원의 여러 위치에 노드가 할당되는 방법말고 링에 부하되는 정보를 분석해 노드를 링 에서 움직여 과도한 로드를 완화하는 방법을 쓴다고 함</li>
          <li>이게 설계와 구현을 다루기 쉽다나 뭐라나..</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>디스코드
    <ul>
      <li>참고 문헌 주소 보고 들어가도 자꾸 메인으로 나가짐 어디 있는지 모르겠음→ 패스</li>
    </ul>
  </li>
  <li><a href="https://theory.stanford.edu/~tim/s16/l/l1.pdf">아카마이(Akamai) CDN</a>  <br />
  <img src="https://github.com/SoonMyeong/programmers/assets/31875043/b9fa21a8-1979-4d9e-8375-797de09c90a0" alt="image" />
    <ul>
      <li>여기서도 책에서 말한 내용들이 그대로 적혀 있음</li>
      <li>Consistent hashing remains in use in modern P2P networks, including for some features
  of the BitTorrent protocol.
        <ul>
          <li>P2P 에서도 일관된 해싱을 사용하나봄</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>매그레프(Meglev) 네트워크 부하 분산기
    <ul>
      <li>lookup 테이블 관련된 해싱 얘기가 나오긴 하는데.. 읽다 잘 모르겠어서 접음</li>
    </ul>
  </li>
</ul>]]></content><author><name>Soon</name></author><category term="book" /><category term="hash" /><category term="consistent hash" /><summary type="html"><![CDATA[대부분의 그림 출처 : https://donghyeon.dev/인프라/2022/03/20/안정-해시-설계/]]></summary></entry></feed>